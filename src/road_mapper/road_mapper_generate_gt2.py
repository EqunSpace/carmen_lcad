'''
This program reads a SVG file generated by Inkscape and searches for "paths" containing a lane width and a sequence of points centered along a road lane.
The paths are then expanded to a continuum of points according to the cubic Bezier curve algorithm.
The road lane map is generated for all points within the lane width, setting the distance to the center of the lane, the lane orientation and the lane markings according to a color code. 
'''
import sys
import numpy as np
import cv2
import struct
from xml.dom import minidom
import argparse

# from cv2 import CV_WINDOW_AUTOSIZE

# Global definitions
VERBOSE = 0
ANIMATION = 0
BEZIER_FRACTION = 0.001     # Line length increment (from 0.000 to 1.000) to set cubic Bezier curve points (number of points = 1/fraction) 
MM_PER_PIXEL = 200.0        # Pixel length in millimeters
ORIENTATION_VECTOR_MODULUS = (2**15 - 1)
NO_MARKING = 0
BROKEN_LINE = 1
SOLID_LINE = 2

class road:
    def __init__(self):
        self.distance_center = -1    # short: 'h'
        self.x_orientation = -1      # short: 'h'
        self.y_orientation = -1      # short: 'h'
        self.left_marking = -1       # char:  'b'
        self.right_marking = -1      # char:  'b'
        self.lane_number = 0
        self.in_the_lane = False

#https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths
def svg_d_get_bezier_points(d):
    letter = ''
    count = 0
    points = [] # list of (x,y)
    last_abs_point_i = 0
    errors = 0
    n_ms = 0
    for p in d.split(' '):    
        if len(p) == 1:
            if p == 'm' or p == 'M' or p == 'c' or p == 'C' or p == 'l' or p == 'L': # or p == 'h' or p == 'H' or p == 'v' or p == 'V':
                if p != letter:
                    count = 0
                letter = p
            else:
                errors += 1
        else:  
            if letter == 'm' or letter == 'M': # Move cursor to (x,y), lowercase = relative coordinates, uppercase = absolute coordinates
                pt = p.split(',')
                if n_ms > 0: # In case we have more than 1 (m or M)
                    points.append(points[-1]) # Repeat last point just to fake the Bezier algorithm
                    if letter == 'm':
                        # calculate absolute point
                        delta = pt
                        points.append((float(delta[0]) + points[-1][0], float(delta[1]) + points[-1][1]))
                    else:
                        points.append((float(pt[0]), float(pt[1])))
                    points.append(points[-1]) # Repeat new point just to fake the Bezier algorithm
                    last_abs_point_i = len(points) - 1
                else:
                    if len(pt) == 2:
                        points.append((float(pt[0]), float(pt[1])))
                        n_ms += 1
                    else:
                        errors += 1             
            elif letter == 'c': # Cubic Bezier curve, lowercase = relative coordinates
                count += 1   
                delta = p.split(',')
                # calculate absolute point
                if len(delta) == 2:                
                    pt[0] = float(delta[0]) + points[last_abs_point_i][0]
                    pt[1] = float(delta[1]) + points[last_abs_point_i][1]
                    points.append((float(pt[0]), float(pt[1])))     
                    if count % 3 == 0:
                        last_abs_point_i = len(points) - 1
                else:
                    errors +=1                            
            elif letter == 'C': # Cubic Bezier curve, uppercase = absolute coordinates
                count += 1            
                pt = p.split(',') 
                if len(pt) == 2:
                    points.append((float(pt[0]), float(pt[1])))
                    last_abs_point_i = len(points) - 1
                else:
                    errors +=1                            
            elif letter == 'l': # Draw straight line to next point (x,y), lowercase = relative coordinates
                delta = p.split(',')
                # calculate absolute point
                if len(delta) == 2:                
                    points.append(points[-1]) # Repeat last point just to fake the Bezier algorithm
                    pt[0] = float(delta[0]) + points[last_abs_point_i][0]
                    pt[1] = float(delta[1]) + points[last_abs_point_i][1]
                    points.append((float(pt[0]), float(pt[1])))
                    last_abs_point_i = len(points) - 1
                    points.append(points[-1]) # Repeat new point just to fake the Bezier algorithm
                else:
                    errors += 1             
            elif letter == 'L': # Draw straight line to next point (x,y), uppercase = absolute coordinates
                pt = p.split(',') 
                if len(pt) == 2:                
                    points.append(points[-1]) # Repeat last point just to fake the Bezier algorithm
                    points.append((float(pt[0]), float(pt[1])))
                    last_abs_point_i = len(points) - 1
                    points.append(points[-1]) # Repeat new point just to fake the Bezier algorithm
                else:
                    errors += 1             
            else:
                errors += 1
        if errors == 1:
            print 'Error in SVG line: d="', d, '"'
        if errors >= 1:
            print 'Unexpected SVG token: ', p
    return points

#https://stackoverflow.com/questions/15857818/python-svg-parser
def svg_get_paths(svg_file):
    doc = minidom.parse(svg_file)  # parseString also exists    
    paths = []
    img = doc.getElementsByTagName('image')
    width = int(img[0].getAttribute('width'))
    height = int(img[0].getAttribute('height'))
    for path in doc.getElementsByTagName('path'):
        d = path.getAttribute('d')
        points = svg_d_get_bezier_points(d)
        for style in path.getAttribute('style').split(';'):
            s = style.split(':')
            if s[0] == 'stroke-width':
                stroke_width = float(s[1]) 
            if s[0] == 'stroke': # this field has the stroke color
                # stroke-color codes the lane marking according to readme.txt
                stroke_color = s[1]
        paths.append((points, stroke_width, stroke_color))
    doc.unlink()
    return width, height, paths

def normalize(a, b):
    norm = np.sqrt(a * a + b * b)
    if norm == 0.0:
        return a, b
    return (a / norm), (b / norm)

#https://stackoverflow.com/questions/785097/how-do-i-implement-a-b%C3%A9zier-curve-in-c
#https://stackoverflow.com/questions/37642168/how-to-convert-quadratic-bezier-curve-code-into-cubic-bezier-curve
def getPt(n1, n2 , perc):
    diff = n2 - n1;
    return n1 + ( diff * perc )

def get_bezier(width, height, lane, fraction, points):
    # width, heigh (image dimensions): used for adjustment of point coordinates
    # lane number in SVG file
    # fraction = 1 / number of real points each Bezier segment generates 
    # points: Bezier polyline parameters
    bx = []
    by = []
    bxo = []
    byo = []
    for i in range((len(points)-1)/3):
        j = 0.0
        while j <= 1.0:
            # The Green Lines
            xa = getPt(points[i*3][0], points[i*3+1][0], j)
            ya = getPt(points[i*3][1], points[i*3+1][1], j)
            xb = getPt(points[i*3+1][0], points[i*3+2][0], j)
            yb = getPt(points[i*3+1][1], points[i*3+2][1], j)
            xc = getPt(points[i*3+2][0], points[i*3+3][0], j)
            yc = getPt(points[i*3+2][1], points[i*3+3][1], j)
            # The Blue Line
            xm = getPt(xa, xb, j)
            ym = getPt(ya, yb, j)
            xn = getPt(xb, xc, j)
            yn = getPt(yb, yc, j)    
            # The Black Dot
            x = getPt(xm, xn, j)
            y = getPt(ym, yn, j)      
            bx.append(x)
            by.append(height - y) # Image's Y axis orientation is downwards, but IARA's orientation is upwards
            if len(bx) == 2:
                last_byo, last_bxo = normalize(by[1] - by[0], bx[1] - bx[0])
                bxo.append(last_bxo)
                byo.append(last_byo)
            if len(bx) >= 3:
                next_byo, next_bxo = normalize(by[-1] - by[-2], bx[-1] - bx[-2])
                avg_byo, avg_bxo = normalize((last_byo + next_byo) / 2.0, (last_bxo + next_bxo) / 2.0)
                last_bxo = next_bxo
                last_byo = next_byo
                bxo.append(avg_bxo)
                byo.append(avg_byo)
            j += fraction
    if len(bx) < 2:
        print 'Invalid Bezier curve in lane number', lane,': len(points) =', len(points), ', len(bx) =', len(bx), ', len(by) =', len(by)
        return [], [], [], []
    bxo.append(last_bxo)
    byo.append(last_byo)
    return bx, by, bxo, byo

#     # Consolidate Bezier points into image pixels
#     bx2 = []
#     by2 = []
#     bxo2 = []
#     byo2 = []
#     last_x = int(round(bx[0]))
#     last_y = int(round(by[0]))
#     sum_bxo = bxo[0]
#     sum_byo = byo[0]
#     count = 1
#     for i in range(1, len(bx)):
#         x = int(round(bx[i]))
#         y = int(round(by[i]))
#         if x != last_x or y != last_y:
#             avg_bxo = sum_bxo / count
#             avg_byo = sum_byo / count
#             bx2.append(last_x)
#             by2.append(last_y)
#             bxo2.append(avg_bxo)
#             byo2.append(avg_byo)
#             last_x = x
#             last_y = y
#             sum_bxo = bxo[i]
#             sum_byo = byo[i]
#             count = 1
#         else:
#             sum_bxo += bxo[i]
#             sum_byo += byo[i]
#             count += 1
#     avg_bxo = sum_bxo / count
#     avg_byo = sum_byo / count
#     bx2.append(last_x)
#     by2.append(last_y)
#     bxo2.append(avg_bxo)
#     byo2.append(avg_byo)
#     return bx2, by2, bxo2, byo2

def scalar_product(dx1, dy1, dx2, dy2):
    d_cos = dx1 * dx2 + dy1 * dy2
    d_sin = dy1 * dx2 - dx1 * dy2
    return d_cos, d_sin

def distance_to_line(x, y, bx, by, bxo, byo):
    # Perform a binary search for a dot product (scalar product) near zero (orthogonal vectors)
    # Scalar product of vectors A and B is ||A||.||B||.cos(a' - b') = ||A||.||B||.(cos a'.cos b' + sen a'.sen b')
    # A = vector (bx, by) - (x, y)
    # B = unit vector (bxo, byo)
    i0 = 0
    dx0 = bx[i0] - x
    dy0 = by[i0] - y
    dbx0 = bxo[i0]
    dby0 = byo[i0]
    dbc0, dbs0 = scalar_product(dx0, dy0, dbx0, dby0)
    i1 = len(bx) - 1
    dx1 = bx[i1] - x
    dy1 = by[i1] - y
    dbx1 = bxo[i1]
    dby1 = byo[i1]
    dbc1, dbs1 = scalar_product(dx1, dy1, dbx1, dby1)
    if VERBOSE >= 3: print '\ti0 =', i0, ' i1 =', i1, ' dbc0 =', dbc0, ' dbs0 =', dbs0, 'dbc1 =', dbc1, ' dbs1 =', dbs1, \
                           ' bx0 =', bx[i0],' by0 =', by[i0], ' bx1 =', bx[i1],' by1 =', by[i1], \
                           ' dx0 =', dx0, ' dy0 =', dy0, ' dbx0 =', dbx0, ' dby0 =', dby0, \
                           ' dx1 =', dx1, ' dy1 =', dy1, ' dbx1 =', dbx1, ' dby1 =', dby1    
    while (i1 - i0) > 1 and np.signbit(dbc1) != np.signbit(dbc0):
        i2 = int((i0 + i1) / 2)
        dx2 = bx[i2] - x
        dy2 = by[i2] - y
        dbx2 = bxo[i2]
        dby2 = byo[i2]
        dbc2, dbs2 = scalar_product(dx2, dy2, dbx2, dby2)
        if np.signbit(dbc2) != np.signbit(dbc0):
            i1 = i2
            dbc1 = dbc2
            dbs1 = dbs2
        else:
            i0 = i2    
            dbc0 = dbc2
            dbs0 = dbs2
        if VERBOSE >= 3: print '\ti0 =', i0, ' i1 =', i1, ' dbc0 =', dbc0, ' dbs0 =', dbs0, 'dbc1 =', dbc1, ' dbs1 =', dbs1, \
                               ' bx0 =', bx[i0],' by0 =', by[i0], ' bx1 =', bx[i1],' by1 =', by[i1], \
                               ' i2 =', i2, ' dx2 =', dx2, ' dy2 =', dy2, ' dbx2 =', dbx2, ' dby2 =', dby2, ' dbc2 =', dbc2, ' dbs2 =', dbs2    
    if abs(dbc1) < abs(dbc0):
        i0 = i1
        dbc0 = dbc1
        dbs0 = dbs1
    d = np.sqrt((bx[i0] - x) * (bx[i0] - x) + (by[i0]- y) * (by[i0] - y))  
    return d, dbc0, dbs0, bxo[i0], byo[i0]

def get_lane_marking_by_color_code(stroke_color):
    if stroke_color == '#ff0000':
        l_marking = SOLID_LINE
        r_marking = SOLID_LINE 
    elif stroke_color == '#ff007f':
        l_marking = BROKEN_LINE
        r_marking = SOLID_LINE 
    elif stroke_color == '#7f00ff':
        l_marking = SOLID_LINE
        r_marking = BROKEN_LINE 
    elif stroke_color == '#0000ff':
        l_marking = BROKEN_LINE
        r_marking = BROKEN_LINE
    elif stroke_color == '#00ff00':
        l_marking = NO_MARKING
        r_marking = NO_MARKING
    elif stroke_color == '#ff7f00':
        l_marking = NO_MARKING
        r_marking = SOLID_LINE
    elif stroke_color == '#7fff00':
        l_marking = SOLID_LINE
        r_marking = NO_MARKING
    elif stroke_color == '#007fff':
        l_marking = NO_MARKING
        r_marking = BROKEN_LINE
    elif stroke_color == '#00ff7f':
        l_marking = BROKEN_LINE
        r_marking = NO_MARKING
    else:
        l_marking = NO_MARKING
        r_marking = NO_MARKING
    return l_marking, r_marking

def get_lane_from_bezier(map, bx, by, bxo, byo, lane, stroke_width, stroke_color, image):
    # map of lanes in a grid of pixels
    # bx, by: Bezier curve points
    # bxo, byo: Bezier curve points orientation
    # lane number in SVG file
    # stroke width of the lane
    # stroke color of the lane
    # image for displaying the animation
    height = len(map)
    width = len(map[0])
    max_distance = stroke_width / 2.0
    l_marking, r_marking = get_lane_marking_by_color_code(stroke_color)
    last_x = last_y = np.NaN
    cont = 0
    for i in range(len(bx)):
        x = int(round(bx[i]))
        y = int(round(by[i]))
        if x == last_x and y == last_y:
            if VERBOSE >= 2: print 'i =', i, ': Current and previous Bezier points are located in the same map pixel: x =', x, ', y =', y, ', bx =', bx[i], ', by =', by[i]
            continue
        last_x = x
        last_y = y
        neighbors = [(x, y)]
        while len(neighbors) > 0:
            x, y = neighbors.pop()
            if x < 0 or x >= width or y < 0 or y >= height:
                if VERBOSE >= 2: print 'i =', i, ': Pixel coordinates are out of map limits: x =', x, ', y =', y, ', width =', width, ', height =', height
                continue
            if map[y][x].lane_number == lane:
                if VERBOSE >= 2: print 'i =', i, ': Map pixel has already been analyzed by current lane number', lane, ': x =', x, ', y =', y
                continue
            if map[y][x].in_the_lane:
                if VERBOSE >= 2: print 'i =', i, ': Map pixel is already inside lane number', map[y][x].lane_number, ': x =', x, ', y =', y
                continue
            cont += 1
            if VERBOSE >= 3: print 'i =', i, ': distance_to_line call #', cont, ': x =', x, ', y =', y  
            d, dbcos, dbsin, dbx, dby = distance_to_line(x, y, bx, by, bxo, byo)
            map[y][x].lane_number = lane
            if d > max_distance:
                if VERBOSE >= 2: print 'i =', i, ': Map pixel is out of the current lane number', lane, ': d =', d, ', max_distance =', max_distance, ': x =', x, ', y =', y
                continue
            if d > 1.0 and abs(dbcos) > 1.0:
                if VERBOSE >= 2: print 'i =', i, ': Map pixel is not orthogonal to the current lane number', lane, ': d =', d, ': dbcos =', dbcos, ', arccos =', np.arccos(dbcos / d), ': x =', x, ', y =', y
                continue
            map[y][x].distance_center = int(round(d * MM_PER_PIXEL) * np.sign(dbsin))  # distance in millimeters from the pixel to the center of the lane
            map[y][x].x_orientation = int(round(dbx * ORIENTATION_VECTOR_MODULUS))
            map[y][x].y_orientation = int(round(dby * ORIENTATION_VECTOR_MODULUS))
            map[y][x].left_marking = l_marking
            map[y][x].right_marking = r_marking
            map[y][x].in_the_lane = True 
            if VERBOSE >= 1: print 'i =', i, ': lane =', lane, ', x =', x, ', y =', y, ': d =', d, 'pixels, d =', map[y][x].distance_center, 'mm', \
                                   ', dbx =', dbx, ', dby =', dby, ', orientation =', np.arctan2(dby, dbx) / np.pi * 180, 'degrees', \
                                   ', x_orientation =', map[y][x].x_orientation, ', y_orientation =', map[y][x].y_orientation, \
                                   ', left_marking =', map[y][x].left_marking, ', right_marking =', map[y][x].right_marking
            for dy in (-1, 0, 1):   # Analyze the neighbor pixels
                for dx in (-1, 0, 1):
                    neighbors.append((x + dx, y + dy))
                    if VERBOSE >= 2: print '\tNeighbor pixel added: (x + dx) =', x + dx, ', (y + dy) =', y + dy
            if ANIMATION > 0:
                image[height - 1 - y][x] = (255, 255, 255)
                cv2.imshow("distance to center of lane", image)
                cv2.waitKey(ANIMATION)
    return map

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='This program reads a SVG file created by Inkscape, searches for "paths", then generates a road map file.', 
                                     formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('-v', '--verbose', help='output verbosity level', type=int, choices=range(4), nargs='?', const=1, default=0)
    parser.add_argument('-a', '--animation', help='animation wait time in milliseconds', type=int, nargs='?', const=1, default=0)
    parser.add_argument('svg_file', help='SVG filename', nargs='?', default='data/i7730800_-357770.00.svg')
    args = parser.parse_args()
    VERBOSE = args.verbose
    if VERBOSE > 0: print 'Verbose option set to level', VERBOSE
    ANIMATION = args.animation
    if ANIMATION > 0: print 'Animation option set to', ANIMATION, 'millisecond' + 's' * (ANIMATION > 1)
    img_file =  args.svg_file[:-4] + '.png'
    print 'Processing SVG file:', args.svg_file
    width, height, paths = svg_get_paths(args.svg_file)
    img1 = np.zeros((height, width, 3), np.uint8)
    img2 = np.zeros((height, width, 3), np.uint8)
    img3 = np.zeros((height, width, 3), np.uint8)
    cv2.namedWindow("cubic Bezier curve", cv2.WINDOW_NORMAL)
    cv2.moveWindow("cubic Bezier curve", 10, 10)
    cv2.namedWindow("distance to center of lane", cv2.WINDOW_NORMAL)
    cv2.moveWindow("distance to center of lane", 78 + width, 10)
    cv2.namedWindow("lane orientation", cv2.WINDOW_NORMAL)
    cv2.moveWindow("lane orientation", 78 + width, 128 + height)
    
    #cv2.namedWindow("rot", cv2.WINDOW_NORMAL)
#     cv2.namedWindow("roi", cv2.WINDOW_NORMAL)
#     cv2.namedWindow("roi2", cv2.WINDOW_NORMAL)
#     print img_file
#     img4 = cv2.imread(img_file, 0)
    
    map = []
    for y in range(height):
        map.append([])
        for x in range(width):        
            map[y].append(road())
    lane = 0
    for path in paths:
        lane += 1
        bx, by, bxo, byo = get_bezier(width, height, lane, BEZIER_FRACTION, points = path[0])
        for i in range(len(bx)):
            x = int(round(bx[i]))
            y = int(round(height - by[i]))
            #print bx[i], x, height - by[i], y
            if 0 <= x < width and 0 <= y < height:
                img1[y][x] = (255, 0, 0)
                
#                 # code to generate ROIs
#                 if i % 20 == 0:
#                     # rotate image to always get the lane in the vertical
#                     angle = -np.arctan2(byo[i], bxo[i]) * 180 / np.pi + 90
#                     rot_mat = cv2.getRotationMatrix2D((x, y), angle, 1.0 )
#                     img5 = cv2.warpAffine(img4, rot_mat, img4.shape, flags=cv2.INTER_NEAREST)
#                     roi_half_width = 12
#                     roi_height = 80
#                     roi_y1 = y - roi_height
#                     roi_x1 = x - roi_half_width
#                     roi_y2 = y
#                     roi_x2 = x + roi_half_width                    
#                     if 0 <= roi_x1 < width and 0 <= roi_x2 < width and 0 <= roi_y1 < height and 0 <= roi_y2 < height:
#                         #print x, y, roi_x1, roi_y1, roi_x2, roi_y2
#                         img6 = img5[roi_y1:roi_y2+1, roi_x1:roi_x2+1]
#                         img7 = img4[roi_y1:roi_y2+1, roi_x1:roi_x2+1]
#                         img6[roi_height-1][roi_half_width] = 255
#                         cv2.imshow("image", img4)
#                         #cv2.imshow('rot', img5)
#                         cv2.imshow('roi', img6)
#                         cv2.imshow('roi2', img7)
#                         cv2.waitKey(0)
        cv2.imshow("cubic Bezier curve", img1)
        map = get_lane_from_bezier(map, bx, by, bxo, byo, lane, stroke_width = path[1], stroke_color = path[2], image = img2)
    for y in range(height):
        for x in range(width):
            if map[y][x].in_the_lane:
                blue = map[y][x].right_marking + map[y][x].left_marking * 10
                distance = int(round(map[y][x].distance_center / 10)) # distance in centimeters
                green = (not np.signbit(distance)) * distance  # green = positive distances = right hand
                red = np.signbit(distance) * abs(distance) # red = negative distances = left hand
                img2[height - 1 - y][x] = (blue, green, red)
                orientation = np.arctan2(map[y][x].y_orientation, map[y][x].x_orientation)
                degrees = int(round(orientation / np.pi * 180)) # orientation in range (-180, 180) degrees
                green = (not np.signbit(degrees)) * degrees  # green = positive degrees
                red = np.signbit(degrees) * abs(degrees) # red = negative degrees
                img3[height - 1 - y][x] = (blue, green, red)
    cv2.imshow("distance to center of lane", img2)
    cv2.imshow("lane orientation", img3)
    print 'Press "Esc" key on the image to continue...'
    while cv2.waitKey(0) & 0xFF != 0x1B: pass
    cv2.destroyAllWindows()
    svg_filename = args.svg_file.split('/')[-1]
    svg_pathname = args.svg_file[:-len(svg_filename)]
    road_file = open(svg_pathname + 'r' + svg_filename[1:-4] + '.map', 'wb')
    for y in range(height):
        for x in range(width):
            m = map[y][x]
            road_file.write(struct.pack('hhhbb', m.distance_center, m.x_orientation, m.y_orientation, m.left_marking, m.right_marking))
    road_file.close()