PROG_DESCRIPTION = \
'''
Input: This program reads one or more SVG files generated by Inkscape and searches for "paths" containing sequences of 
       Bezier curve points. The paths are then expanded to sequences of RDDF points according to the cubic Bezier curve algorithm.
       
Output: The RDDFs files corresponding to each path of each SVG file
'''
import sys, os, argparse
import math
import time;
from xml.dom import minidom

# Global definitions
BEZIER_INCREMENT = 0.01     # Increment in meters to draw cubic Bezier curve points (number of points = meters/increment) 
VELOCITY = (10 / 3.6)       # Default x-axis velocity in m/s
PHI = 0.0                   # Default steering angle phi in radians


def is_float(var):
    if isinstance(var, list) or isinstance(var, tuple):
        for element in var:
            if not is_float(element):
                return False
    else:
        try:
            float(var)
        except ValueError:
            return False
    return True


#https://wiki.inkscape.org/wiki/index.php/Units_In_Inkscape
def svg_pixels_to_meters(px):
    if svg_type == 'px':
        m = px * svg_scale
    elif svg_type == 'mm':
        m = px / 96.0 * 25.4 * svg_scale  # 1 pixel = 1/96 inch; 1 inch = 25.4 mm
    else:
        raise ValueError('Invalid SVG scale type: {}'.format(svg_type))
    return m


def convert_coordinates_from_svg_to_carmen(svg_points, svg_orientation, svg_height, origin):
    carmen_points = []; carmen_orientation = []
    (x_origin, y_origin) = origin
    for i in range(len(svg_points)):
        (x, y) = svg_points[i]
        (dx, dy) = svg_orientation[i]
        x_carmen = x
        y_carmen = svg_height - y   # SVG y-axis orientation is downwards, but CARMEN y-axis orientation is upwards
        x_m = svg_pixels_to_meters(x_carmen) + x_origin
        y_m = svg_pixels_to_meters(y_carmen) + y_origin
        dx_carmen = dx
        dy_carmen = -dy             # SVG y-axis orientation is downwards, but CARMEN y-axis orientation is upwards
        carmen_points.append((x_m, y_m))
        carmen_orientation.append((dx_carmen, dy_carmen))
    return carmen_points, carmen_orientation


def normalize(point):
    if point == None:
        return None
    (x, y) = point
    (norm_x, norm_y) = (0.0, 0.0)
    norm = math.sqrt(x * x + y * y)
    if norm != 0.0:
        norm_x = x / norm
        norm_y = y / norm
    return (norm_x, norm_y)


def delta(point1, point2):
    if point1 == None:
        delta_point = point2
    elif point2 == None:
        delta_point = point1
    else:
        (x1, y1) = point1
        (x2, y2) = point2
        delta_point = ((x1 - x2), (y1 - y2))
    n_point = normalize(delta_point)
    return n_point


def avg(point1, point2):
    if point1 == None:
        avg_point = point2
    elif point2 == None:
        avg_point = point1
    else:
        (x1, y1) = point1
        (x2, y2) = point2
        avg_point = ((x1 + x2) / 2, (y1 + y2) / 2)
    n_point = normalize(avg_point)
    return n_point


def avg_base_point(bezier, index, last_orientation, next_orientation):
    last_base = next_base = None
    if index > 0 and bezier[index] != bezier[index - 1]:
        last_base = delta(bezier[index], bezier[index - 1])
    if index < (len(bezier) - 1) and bezier[index + 1] != bezier[index]:
        next_base = delta(bezier[index + 1], bezier[index])
    orientation = avg(last_base, next_base)
    if not orientation:
        orientation = avg(last_orientation, next_orientation)
    return orientation


def ratio(point1, point2, factor):
    if point1 == None:
        return point2
    elif point2 == None:
        return point1
    (x1, y1) = point1
    (x2, y2) = point2
    r_x = x1 + ((x2 - x1) * factor)
    r_y = y1 + ((y2 - y1) * factor)
    return (r_x, r_y)


def distance(point1, point2):
    if point1:
        (x1, y1) = point1
    else:
        (x1, y1) = (0.0, 0.0)
    if point2:
        (x2, y2) = point2
    else:
        (x2, y2) = (0.0, 0.0)
    (dx, dy) = ((x1 - x2), (y1 - y2))
    dist = math.sqrt(dx * dx + dy * dy)
    return dist


#https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths
def get_bezier_points_from_svg_path(path_id, path_d):
    letter = ''
    count = 0
    points = [] # list of (x,y) in SVG coordinates
    last_abs_point_i = 0
    total_errors = errors = 0
    n_ms = 0
    for p in path_d.split():
        if len(p) == 1:
            if p in 'MmCcLl': # also 'HhVv'
                if p != letter:
                    count = 0
                letter = p
            else:
                errors += 1
        else:  
            if letter in 'Mm': # Move cursor to (x,y), lowercase = relative coordinates, uppercase = absolute coordinates
                pt = p.split(',')
                if n_ms > 0: # In case we have more than 1 (m or M)
                    points.append(points[-1]) # Repeat last point just to fake the Bezier algorithm
                    if letter == 'm':
                        # calculate absolute point
                        delta = pt
                        points.append((float(delta[0]) + points[-1][0], float(delta[1]) + points[-1][1]))
                    else:
                        points.append((float(pt[0]), float(pt[1])))
                    points.append(points[-1]) # Repeat new point just to fake the Bezier algorithm
                    last_abs_point_i = len(points) - 1
                else:
                    if len(pt) == 2:
                        points.append((float(pt[0]), float(pt[1])))
                        n_ms += 1
                    else:
                        errors += 1             
            elif letter == 'c': # Cubic Bezier curve, lowercase = relative coordinates
                count += 1   
                delta = p.split(',')
                # calculate absolute point
                if len(delta) == 2:                
                    pt[0] = float(delta[0]) + points[last_abs_point_i][0]
                    pt[1] = float(delta[1]) + points[last_abs_point_i][1]
                    points.append((float(pt[0]), float(pt[1])))     
                    if count % 3 == 0:
                        last_abs_point_i = len(points) - 1
                else:
                    errors +=1                            
            elif letter == 'C': # Cubic Bezier curve, uppercase = absolute coordinates
                count += 1            
                pt = p.split(',') 
                if len(pt) == 2:
                    points.append((float(pt[0]), float(pt[1])))
                    last_abs_point_i = len(points) - 1
                else:
                    errors +=1                            
            elif letter == 'l': # Draw straight line to next point (x,y), lowercase = relative coordinates
                delta = p.split(',')
                # calculate absolute point
                if len(delta) == 2:                
                    points.append(points[-1]) # Repeat last point just to fake the Bezier algorithm
                    pt[0] = float(delta[0]) + points[last_abs_point_i][0]
                    pt[1] = float(delta[1]) + points[last_abs_point_i][1]
                    points.append((float(pt[0]), float(pt[1])))
                    last_abs_point_i = len(points) - 1
                    points.append(points[-1]) # Repeat new point just to fake the Bezier algorithm
                else:
                    errors += 1             
            elif letter == 'L': # Draw straight line to next point (x,y), uppercase = absolute coordinates
                pt = p.split(',') 
                if len(pt) == 2:                
                    points.append(points[-1]) # Repeat last point just to fake the Bezier algorithm
                    points.append((float(pt[0]), float(pt[1])))
                    last_abs_point_i = len(points) - 1
                    points.append(points[-1]) # Repeat new point just to fake the Bezier algorithm
                else:
                    errors += 1             
            else:
                errors += 1
        if errors > 0:
            print('Unexpected SVG path token: {}'.format(p))
        total_errors += errors
        errors = 0
    if total_errors > 0:
        print('{} error{} in SVG path id={} d={}'.format(total_errors, 's' * (total_errors > 1), path_id, path_d))
    return points


#https://stackoverflow.com/questions/15857818/python-svg-parser
def get_paths_from_svg(svg_file):
    svg_paths = []
    svg_height = 0
    doc = minidom.parse(svg_file)   
    svg = doc.getElementsByTagName('svg')
    if svg:
        svg_height = float(svg[0].getAttribute('height'))
    for path in doc.getElementsByTagName('path'):
        path_id = path.getAttribute('id')
        path_d = path.getAttribute('d')
        points = get_bezier_points_from_svg_path(path_id, path_d)
        svg_paths.append((path_id, points))
    doc.unlink()
    return svg_paths, svg_height


#https://stackoverflow.com/questions/785097/how-do-i-implement-a-b%C3%A9zier-curve-in-c
#https://stackoverflow.com/questions/37642168/how-to-convert-quadratic-bezier-curve-code-into-cubic-bezier-curve
def get_bezier_curve(points, increment):
    # points: SVG Bezier polyline parameters
    # increment = increment in meters between every two calculated Bezier points 
    bezier = []; bezier_orientation = []
    last_orientation = next_orientation = None
    if len(points) < 4:
        print('Invalid Bezier curve (number of points = {} less than 4): {}'.format(len(points), points))
        return bezier, bezier_orientation
    if (len(points) - 1) % 3 != 0:
        print('Invalid Bezier curve (number of points = {} not 3*N+1): {} ...'.format(len(points), points[:4]))
        return bezier, bezier_orientation

    number_of_base_points = (len(points) - 1) / 3
    for i in range(number_of_base_points):
        (x0, y0) = points[i * 3]
        (x1, y1) = points[i * 3 + 1]
        (x2, y2) = points[i * 3 + 2]
        (x3, y3) = points[i * 3 + 3]
        px = distance((x3, y3), (x0, y0))
        number_of_calculated_points = int(svg_pixels_to_meters(px) / increment)
        for j in range(number_of_calculated_points):
            factor = float(j) / number_of_calculated_points 
            # The Green Lines
            (xa, ya) = ratio((x0, y0), (x1, y1), factor)
            (xb, yb) = ratio((x1, y1), (x2, y2), factor)
            (xc, yc) = ratio((x2, y2), (x3, y3), factor)
            # The Blue Line
            (xm, ym) = ratio((xa, ya), (xb, yb), factor)
            (xn, yn) = ratio((xb, yb), (xc, yc), factor)
            # The Black Dot
            (x, y)   = ratio((xm, ym), (xn, yn), factor)
            bezier.append((x, y))

            if j == 1:
                next_orientation = delta(bezier[-1], bezier[-2])
                bezier_orientation.append(avg_base_point(bezier, (i * 3), last_orientation, next_orientation))
                last_orientation = next_orientation
            elif j > 1:
                next_orientation = delta(bezier[-1], bezier[-2])
                bezier_orientation.append(avg(last_orientation, next_orientation))
                last_orientation = next_orientation
   
        next_orientation = delta((x3, y3), bezier[-1])
        bezier_orientation.append(avg(last_orientation, next_orientation))
        last_orientation = next_orientation

    bezier.append(points[-1])
    bezier_orientation.append(avg_base_point(bezier, (i * 3 + 3), last_orientation, None))
    
    return bezier, bezier_orientation


def get_rddf_from_bezier_curve(points, orientation, rddf_dist_points):
    rddf = []
    dist = rddf_dist_points
    last_point = None
    for i in range(len(points)):
        dist += distance(points[i], last_point)
        if dist >= rddf_dist_points:
            dist = 0.0
            (x, y) = points[i]
            (dx, dy) = orientation[i]
            theta = math.atan2(dy, dx)
            rddf.append((x, y, theta))
        last_point = points[i]
    return rddf


def write_rddf(rddf_file, rddf):
    rddf_f = open(rddf_file, 'w')
    timestamp = time.time()
    for (x, y, theta) in rddf:
        timestamp += (args.dist_points / VELOCITY)
        rddf_f.write(('{:.6f}\t' * 6 + '\n').format(x, y, theta, VELOCITY, PHI, timestamp))
    rddf_f.close()
    print('RDDF file {} generated'.format(rddf_file))


def process_svg_file(svg_file):
    global count_files
    count_files += 1
    print('>>>>> File {} of {} <<<<<'.format(count_files, total_files))
    if not os.path.isfile(svg_file):
        print('Skipped file \'{}\': file not found'.format(svg_file))
        return
    svg_filename = svg_file.split('/')[-1]
    coord = svg_filename[1:-4].split('_')
    if len(coord) != 2 or not is_float(coord) or svg_filename[-4:] != '.svg':
        print('Skipped file \'{}\': expected filename pattern: i<x>_<y>.svg'.format(svg_file))
        return
    origin = [ float(val) for val in coord ]
    print('Processing SVG file: \'{}\''.format(svg_file))
    (svg_paths, svg_height) = get_paths_from_svg(svg_file)
    if not svg_paths:
        print('File \'{}\' contains no path: RDDF was not generated'.format(svg_file))
        return
    for (path_id, bezier_points) in svg_paths:
        rddf_file = args.outputdir + '/rddf_' + svg_filename[1:-4] + '_' + path_id + '.txt'
        if os.path.isfile(rddf_file) and not args.override:
            print('Skipped path id="{}": RDDF file \'{}\' already exists'.format(path_id, rddf_file))
            continue
        (bezier_curve, bezier_orientation) = get_bezier_curve(bezier_points, BEZIER_INCREMENT)
        (points, orientation) = convert_coordinates_from_svg_to_carmen(bezier_curve, bezier_orientation, svg_height, origin)
        rddf = get_rddf_from_bezier_curve(points, orientation, args.dist_points)
        write_rddf(rddf_file, rddf)


def usage_exit(msg):
    if msg:
        print(msg)
    parser.print_help(sys.stderr)
    sys.exit(1)


def _path(s):
    if not os.path.isdir(s):
        raise argparse.ArgumentTypeError('directory not found: {}'.format(s))
    return s


def _file(s):
    if not os.path.isfile(s):
        raise argparse.ArgumentTypeError('file not found: {}'.format(s))
    return s

    
def _svg_scale(s):
    global svg_type, svg_scale
    tokens = s.split('=')
    if len(tokens) == 2:
        (svg_type, svg_scale) = tokens
        if svg_type in ('mm', 'px') and svg_scale[-1] == 'm' and is_float(svg_scale[:-1]):
            svg_scale = float(svg_scale[:-1])
            return s
    raise argparse.ArgumentTypeError('SVG scale is not in format: {mm|px}=<meters>m   (default: mm=1.0m):  ' + s)

    
def main():
    global parser, args, count_files, total_files
    print
    
    parser = argparse.ArgumentParser(description=PROG_DESCRIPTION, formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('-o', '--outputdir', help='RDDF output directory   (default: .)', type=_path, default='.')
    parser.add_argument('-x', '--override', help='override existing RDDF files   (default: False)', action='store_true', dest='override', default=False)
    parser.add_argument('-s', '--scale', help='SVG scale: {mm|px}=<meters>m   (default: mm=1.0m)', type=_svg_scale, default='mm=1.0m')
    parser.add_argument('-d', '--dist_points', help='RDDF distance between waypoints in meters   (default: 0.5)', type=float, default=0.5)
    parser.add_argument('-f', '--filelist', help='text file containing a list of SVG filenames (one per line)', type=_file)
    parser.add_argument('filename', help='list of SVG filenames (separated by spaces)', type=_file, nargs='*')
    args = parser.parse_args()

    if args.dist_points <= 0.0:
        usage_exit('RDDF distance between waypoints must be a positive value in meters: {}\n\n'.format(args.dist_points))
    
    if not args.filelist and not args.filename:
        if len(sys.argv) > 1:
            usage_exit('At least a filename or a filelist must be passed as argument\n\n')
        usage_exit('')
    
    count_files = 0
    total_files = len(args.filename)
    if args.filelist:
        fl = open(args.filelist)
        filelist = [ f.strip() for f in fl.readlines() if f.strip() and f.strip()[0] != '#' ]
        fl.close()
        total_files += len(filelist)

    if args.filename:
        print('********** Processing {} file{} from commandline'.format(len(args.filename), 's' * (len(args.filename) > 1))) 
        for f in args.filename:
            process_svg_file(f)

    if args.filelist:
        print('********** Processing \'{}\' filelist containing {} file{}'.format(args.filelist, len(filelist), 's' * (len(filelist) > 1))) 
        for f in filelist:
            process_svg_file(f)

if __name__ == "__main__":
    main()
