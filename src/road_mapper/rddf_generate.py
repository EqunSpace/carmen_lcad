PROG_DESCRIPTION = \
'''
Input: This program reads one or more SVG files generated by Inkscape and searches for "paths" containing sequences of 
       Bezier curve points. The paths are then expanded to sequences of RDDF points according to the cubic Bezier curve algorithm.
       
Output: The RDDFs files corresponding to each path in each SVG file
'''
import sys
import os
import argparse
import math
import time;
from xml.dom import minidom

# Global definitions
SVG_MAP_SCALE = 1000.0      # 1 metric unit of a map coordinate in SVG file = SVG_MAP_SCALE metric units in real world
BEZIER_INCREMENT = 0.001    # Increment in meters to draw cubic Bezier curve points (number of points = meters/increment) 
RDDF_DISTANCE = 0.5         # Distance in meters between RDDF waypoints = rddf_min_distance_between_waypoints
VELOCITY = 2.78             # Default velocity.x
PHI = 0.0                   # Default phi


def is_float(var):
    if isinstance(var, list) or isinstance(var, tuple):
        for element in var:
            if not is_float(element):
                return False
    else:
        try:
            float(var)
        except ValueError:
            return False
    return True


#https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths
def get_bezier_points_from_svg_path(path_id, path_d):
    letter = ''
    count = 0
    points = [] # list of (x,y) in SVG coordinates
    last_abs_point_i = 0
    total_errors = errors = 0
    n_ms = 0
    for p in path_d.split():
        if len(p) == 1:
            if p in 'MmCcLl': # also 'HhVv'
                if p != letter:
                    count = 0
                letter = p
            else:
                errors += 1
        else:  
            if letter in 'Mm': # Move cursor to (x,y), lowercase = relative coordinates, uppercase = absolute coordinates
                pt = p.split(',')
                if n_ms > 0: # In case we have more than 1 (m or M)
                    points.append(points[-1]) # Repeat last point just to fake the Bezier algorithm
                    if letter == 'm':
                        # calculate absolute point
                        delta = pt
                        points.append((float(delta[0]) + points[-1][0], float(delta[1]) + points[-1][1]))
                    else:
                        points.append((float(pt[0]), float(pt[1])))
                    points.append(points[-1]) # Repeat new point just to fake the Bezier algorithm
                    last_abs_point_i = len(points) - 1
                else:
                    if len(pt) == 2:
                        points.append((float(pt[0]), float(pt[1])))
                        n_ms += 1
                    else:
                        errors += 1             
            elif letter == 'c': # Cubic Bezier curve, lowercase = relative coordinates
                count += 1   
                delta = p.split(',')
                # calculate absolute point
                if len(delta) == 2:                
                    pt[0] = float(delta[0]) + points[last_abs_point_i][0]
                    pt[1] = float(delta[1]) + points[last_abs_point_i][1]
                    points.append((float(pt[0]), float(pt[1])))     
                    if count % 3 == 0:
                        last_abs_point_i = len(points) - 1
                else:
                    errors +=1                            
            elif letter == 'C': # Cubic Bezier curve, uppercase = absolute coordinates
                count += 1            
                pt = p.split(',') 
                if len(pt) == 2:
                    points.append((float(pt[0]), float(pt[1])))
                    last_abs_point_i = len(points) - 1
                else:
                    errors +=1                            
            elif letter == 'l': # Draw straight line to next point (x,y), lowercase = relative coordinates
                delta = p.split(',')
                # calculate absolute point
                if len(delta) == 2:                
                    points.append(points[-1]) # Repeat last point just to fake the Bezier algorithm
                    pt[0] = float(delta[0]) + points[last_abs_point_i][0]
                    pt[1] = float(delta[1]) + points[last_abs_point_i][1]
                    points.append((float(pt[0]), float(pt[1])))
                    last_abs_point_i = len(points) - 1
                    points.append(points[-1]) # Repeat new point just to fake the Bezier algorithm
                else:
                    errors += 1             
            elif letter == 'L': # Draw straight line to next point (x,y), uppercase = absolute coordinates
                pt = p.split(',') 
                if len(pt) == 2:                
                    points.append(points[-1]) # Repeat last point just to fake the Bezier algorithm
                    points.append((float(pt[0]), float(pt[1])))
                    last_abs_point_i = len(points) - 1
                    points.append(points[-1]) # Repeat new point just to fake the Bezier algorithm
                else:
                    errors += 1             
            else:
                errors += 1
        if errors > 0:
            print('Unexpected SVG path token: {}'.format(p))
        total_errors += errors
        errors = 0
    if total_errors > 0:
        print('{} error{} in SVG path id={} d={}'.format(total_errors, 's' * (total_errors > 1), path_id, path_d))
    return points


#https://stackoverflow.com/questions/15857818/python-svg-parser
def get_paths_from_svg(svg_file):
    svg_paths = []
    svg_height = 0
    doc = minidom.parse(svg_file)   
    svg = doc.getElementsByTagName('svg')
    if svg:
        svg_height = float(svg[0].getAttribute('height'))
    for path in doc.getElementsByTagName('path'):
        path_id = path.getAttribute('id')
        path_d = path.getAttribute('d')
        points = get_bezier_points_from_svg_path(path_id, path_d)
        svg_paths.append(path_id, points)
    doc.unlink()
    return svg_paths, svg_height


#https://wiki.inkscape.org/wiki/index.php/Units_In_Inkscape
def svg_pixels_to_meters(px):
    m = px / 96.0 * 0.0254 * SVG_MAP_SCALE  # 1 pixel = 1/96 inch 
    return m


def convert_coordinates_from_svg_to_carmen(svg_points, svg_orientation, svg_height, origin):
    carmen_points = []; carmen_orientation = []
    (x_origin, y_origin) = origin
    for i in range(len(svg_points)):
        (x, y) = svg_points[i]
        (dx, dy) = svg_orientation[i]
        x_carmen = x
        y_carmen = svg_height - y   # SVG y-axis orientation is downwards, but CARMEN y-axis orientation is upwards
        x_m = svg_pixels_to_meters(x_carmen) + x_origin
        y_m = svg_pixels_to_meters(y_carmen) + y_origin
        dx_carmen = dx
        dy_carmen = - dy
        carmen_points.append(x_m, y_m)
        carmen_orientation.append(dx_carmen, dy_carmen)
    return carmen_points, carmen_orientation


def normalize(point):
    (x, y) = point
    (norm_x, norm_y) = (0.0, 0.0)
    norm = math.sqrt(x * x + y * y)
    if norm != 0.0:
        norm_x = x / norm
        norm_y = y / norm
    return (norm_x, norm_y)


def delta(point1, point2):
    (x1, y1) = point1
    (x2, y2) = point2
    delta_point = ((x1 - x2), (y1 - y2))
    n_point = normalize(delta_point)
    return n_point


def avg(point1, point2):
    (x1, y1) = point1
    (x2, y2) = point2
    avg_point = ((x1 + x2) / 2, (y1 + y2) / 2)
    n_point = normalize(avg_point)
    return n_point


def ratio(point1, point2, factor):
    (x1, y1) = point1
    (x2, y2) = point2
    r_x = x1 + ((x2 - x1) * factor)
    r_y = y1 + ((y2 - y1) * factor)
    return (rx, r_y)


def distance(point1, point2):
    dx = point2[0] - point1[0]
    dy = point2[1] - point1[1]
    dist = math.sqrt(dx * dx + dy * dy)
    return dist


#https://stackoverflow.com/questions/785097/how-do-i-implement-a-b%C3%A9zier-curve-in-c
#https://stackoverflow.com/questions/37642168/how-to-convert-quadratic-bezier-curve-code-into-cubic-bezier-curve
def get_bezier_curve(points, increment):
    # points: SVG Bezier polyline parameters
    # increment = increment in meters between every two calculated Bezier points 
    bezier = []; bezier_orientation = []
    if len(points) < 4:
        print('Invalid Bezier curve (number of points = {} less than 4): {}'.format(len(points),points))
        return bezier, bezier_orientation

    number_of_base_points = (len(points) - 1) / 3
    if (len(points) - 1) % 3 != 0:
        print('Invalid Bezier curve (number of points = {} not 3*N+1): {} ...'.format(len(points), points[:4]))
        return bezier, bezier_orientation

    last_orientation = delta(points[1], points[0])
    
    for i in range(number_of_base_points):
        (x0, y0) = points[i * 3]
        (x1, y1) = points[i * 3 + 1]
        (x2, y2) = points[i * 3 + 2]
        (x3, y3) = points[i * 3 + 3]
        px = distance((x3, y3), (x0, y0))
        number_of_calculated_points = int(svg_pixels_to_meters(px) / increment)
        for j in range(number_of_calculated_points):
            factor = float(j) / number_of_calculated_points 
            # The Green Lines
            (xa, ya) = ratio((x0, y0), (x1, y1), factor)
            (xb, yb) = ratio((x1, y1), (x2, y2), factor)
            (xc, yc) = ratio((x2, y2), (x3, y3), factor)
            # The Blue Line
            (xm, ym) = ratio((xa, ya), (xb, yb), factor)
            (xn, yn) = ratio((xb, yb), (xc, yc), factor)
            # The Black Dot
            (x, y)   = ratio((xm, ym), (xn, yn), factor)
            bezier.append(x, y)
   
        next_orientation = delta((x1, y1), (x0, y0))
        bezier_orientation.append(avg(last_orientation, next_orientation))

        for j in range(1, number_of_calculated_points - 1):
            last_orientation = delta(bezier[j], bezier[j - 1]) 
            next_orientation = delta(bezier[j + 1], bezier[j])
            bezier_orientation.append(avg(last_orientation, next_orientation))

        last_orientation = next_orientation
        next_orientation = delta((x3, y3), bezier[-1])
        bezier_orientation.append(avg(last_orientation, next_orientation))
        last_orientation = delta((x3, y3), (x2, y2))

    bezier.append(points[-1])
    bezier_orientation.append(delta(points[-1], points[-2]))

    return bezier, bezier_orientation


def get_rddf_from_bezier_curve(points, orientation, rddf_distance):
    rddf = []
    dist = 0.0
    last_point = (0.0, 0.0)
    for i in range(len(points)):
        dist += distance(points[i], last_point)
        if i == 0 or dist >= rddf_distance:
            (x, y) = points[i]
            (dx, dy) = orientation[i]
            theta = math.atan2(dy, dx)
            rddf.append(x, y, theta)
            last_point = points[i]
            dist = 0.0
    return rddf


def write_rddf(rddf_file, rddf):
    rddf_f = open(rddf_file, 'w')
    timestamp = time.time()
    for (x, y, theta) in rddf:
        timestamp += (RDDF_DISTANCE / VELOCITY)
        rddf_f.write(('{:.6f}\t' * 6 + '\n').format(x, y, theta, VELOCITY, PHI, timestamp))
    rddf_f.close()
    print('RDDF file {} generated'.format(rddf_file))


def process_svg_file(svg_file):
    global args, g_count_files, g_total_files
    g_count_files += 1
    print('>>>>> File {} of {} <<<<<'.format(g_count_files, g_total_files))
    if not os.path.isfile(svg_file):
        print('Skipped file {}: file not found'.format(svg_file))
        return
    svg_filename = svg_file.split('/')[-1]
    coord = svg_filename[1:-4].split('_')
    if len(coord) != 2 or not is_float(coord) or svg_filename[-4:] != '.svg':
        print('Skipped file {}: expected filename pattern: i<x>_<y>.svg'.format(svg_file))
        return
    origin = (float(coord[0]), float(coord[1]))
    print 'Processing SVG file:', svg_file
    (svg_paths, svg_height) = get_paths_from_svg(svg_file)
    if not svg_paths:
        print('File {} contains no path: RDDF was not generated'.format(svg_file))
        return
    for (path_id, bezier_points) in svg_paths:
        rddf_file = args.outputdir + '/rddf_' + svg_filename[1:-4] + '_' + path_id + '.txt'
        if os.path.isfile(rddf_file) and not args.override:
            print('Skipped path id={}: RDDF file {} already exists'.format(path_id, rddf_file))
            continue
        (bezier_curve, bezier_orientation) = get_bezier_curve(bezier_points, BEZIER_INCREMENT)
        (points, orientation) = convert_coordinates_from_svg_to_carmen(bezier_curve, bezier_orientation, svg_height, origin)
        rddf = get_rddf_from_bezier_curve(points, orientation, RDDF_DISTANCE)
        write_rddf(rddf_file, rddf)


def path(s):
    if not os.path.isdir(s):
        raise argparse.ArgumentTypeError('directory not found: {}'.format(s))
    return s


def file(s):
    if not os.path.isfile(s):
        raise argparse.ArgumentTypeError('file not found: {}'.format(s))
    return s

    
def main():
    global args, g_count_files, g_total_files
    parser = argparse.ArgumentParser(description=PROG_DESCRIPTION, formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('-o', '--outputdir', help='RDDF output directory', type=path, default='.')
    parser.add_argument('-x', '--override', help='override existing RDDF files', action='store_true', dest='override', default=False)
    parser.add_argument('-f', '--filelist', help='text file containing a list of SVG filenames (one per line)', default='', type=file)
    parser.add_argument('filename', help='list of SVG filenames (separated by spaces)', nargs='*', type=file)
    args = parser.parse_args()
    
    if not args.filelist and not args.filename:
        if len(sys.argv) > 1:
            print('At least a filename or a filelist must be used')
        parser.print_help(sys.stderr)
        sys.exit(1)

    g_count_files = 0
    g_total_files = len(args.filename)
    filelist = []
    if args.filelist:
        filelist_f = open(args.filelist)
        filelist = filelist_f.readlines()
        filelist_f.close()
        g_total_files += len(filelist)

    if args.filename:
        print('********** Processing {} filelist containing {} file{}'.format('commandline', len(args.filename), 's' * (len(args.filename) > 1))) 
        for f in args.filename:
            process_svg_file(f)

    if args.filelist:
        print('********** Processing {} filelist containing {} file{}'.format(args.filelist, len(filelist), 's' * (len(filelist) > 1))) 
        for f in filelist:
            process_svg_file(f[:-1])

if __name__ == "__main__":
    main()
